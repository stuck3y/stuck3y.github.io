<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Safari Pac-Man</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body { margin:0; padding:20px; background:#000; font-family:monospace; color:#fff; display:flex; flex-direction:column; align-items:center; }
    canvas { border:2px solid #fff; background:#001122; }
    .ui { margin:10px 0; font-size:16px; }
    .controls { margin:10px 0; font-size:12px; }
  </style>
</head>
<body>
  <div class="ui" id="ui">SCORE: 0 | LIVES: 3 | THEME: Cars (press T)</div>
  <canvas id="game" width="784" height="644"></canvas>
  <div class="controls">Arrow keys to move | T to change theme | R to restart</div>

  <script>
    // Pure vanilla Canvas game - Safari Sequoia guaranteed
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const ui = document.getElementById('ui');
    
    // Game constants
    const TILE = 28; // Bigger tiles for easier visibility
    const COLS = 28;
    const ROWS = 23;
    
    // Simple maze (smaller for testing)
    const MAZE = [
      "############################",
      "#............##............#",
      "#.####.#####.##.#####.####.#",
      "#o####.#####.##.#####.####o#",
      "#..........................#",
      "#.####.##.########.##.####.#",
      "#......##....##....##......#",
      "######.##### ## #####.######",
      "     #.##### ## #####.#     ",
      "     #.##    GG    ##.#     ",
      "######.## ######## ##.######",
      "#P.........................#",
      "######.## ######## ##.######",
      "     #.##          ##.#     ",
      "######.## ######## ##.######",
      "#............##............#",
      "#.####.#####.##.#####.####.#",
      "#o..##................##..o#",
      "###.##.##.########.##.##.###",
      "#......##....##....##......#",
      "#.##########.##.##########.#",
      "#..........................#",
      "############################"
    ];
    
    // Game state
    let score = 0, lives = 3, dots = 0;
    let powerTimer = 0; // frames remaining for power pellet effect
    let gameWon = false, gameLost = false;
    const POWER_DURATION = 300; // frames (5 seconds at 60fps)
    let themeIndex = 0;
    const themes = [
      { name: 'Cars', pacColor: '#ff0000', ghostColors: ['#00ff00', '#0000ff', '#ffff00', '#ff00ff'], road: '#333', wall: '#666' },
      { name: 'Ocean', pacColor: '#ff7700', ghostColors: ['#ff88ff', '#88ffff', '#ffaaff', '#aaaaff'], road: '#002244', wall: '#004466' }
    ];
    
    // Dynamic board state (separate from static MAZE)
    let board = [];
    
    // Entities
    const pac = { x: 1, y: 11, dx: 0, dy: 0, size: 12, rotation: 0 }; // Added rotation
    const ghosts = [
      { x: 13, y: 9, dx: 1, dy: 0, color: 0, size: 10, frightened: false, rotation: 0, type: 'enemy' },
      { x: 14, y: 9, dx: -1, dy: 0, color: 1, size: 10, frightened: false, rotation: Math.PI, type: 'enemy' },
      { x: 12, y: 9, dx: 0, dy: 1, color: 2, size: 10, frightened: false, rotation: Math.PI/2, type: 'enemy' },
      { x: 15, y: 9, dx: 0, dy: -1, color: 3, size: 10, frightened: false, rotation: -Math.PI/2, type: 'enemy' },
      { x: 2, y: 11, dx: 1, dy: 0, color: 4, size: 10, frightened: false, rotation: 0, type: 'ally' } // AI ally
    ];
    
    // Find starting positions and count dots
    function initGame() {
      // Create dynamic board from static MAZE
      board = MAZE.map(row => row.split(''));
      console.log('MAZE length:', MAZE.length, 'ROWS:', ROWS);
      console.log('Board created, length:', board.length);
      dots = 0;
      for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
          if (!board[y]) {
            console.error('Missing board row at y:', y);
            return;
          }
          const cell = board[y][x];
          if (cell === 'P') { pac.x = x; pac.y = y; }
          if (cell === '.' || cell === 'o') dots++;
        }
      }
      console.log('Game initialized. Pac at:', pac.x, pac.y, 'Dots:', dots);
    }
    
    // Input handling
    const keys = {};
    window.addEventListener('keydown', e => {
      keys[e.key] = true;
      if (e.key === 't' || e.key === 'T') switchTheme();
      if (e.key === 'r' || e.key === 'R') restart();
    });
    window.addEventListener('keyup', e => keys[e.key] = false);
    
    function switchTheme() {
      themeIndex = (themeIndex + 1) % themes.length;
      updateUI();
    }
    
    function restart() {
      score = 0; lives = 3; powerTimer = 0; gameWon = false; gameLost = false;
      pac.x = 1; pac.y = 11; pac.dx = 0; pac.dy = 0;
      ghosts.forEach((g, i) => {
        g.x = 13 + i; g.y = 9; g.dx = i === 0 ? 1 : -1; g.dy = 0; g.frightened = false;
      });
      initGame();
      updateUI();
    }
    
    function updateUI() {
      let status = '';
      if (gameWon) status = ' | YOU WIN!';
      else if (gameLost) status = ' | GAME OVER';
      else if (powerTimer > 0) status = ` | POWER: ${Math.ceil(powerTimer/60)}s`;
      
      ui.textContent = `SCORE: ${score} | LIVES: ${lives} | THEME: ${themes[themeIndex].name} (press T)${status}`;
    }
    
    // Helper functions
    function distance(a, b) {
      return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
    }
    
    function checkCollisions() {
      // Pac-Man vs Ghosts
      ghosts.forEach((ghost, i) => {
        if (distance(pac, ghost) < 0.8) {
          if (ghost.type === 'ally') {
            // Allies are friendly - no collision damage
            return;
          }
          
          if (ghost.frightened) {
            // Eat frightened enemy
            score += 200;
            // Reset enemy to center area
            ghost.x = 13 + (i % 4); 
            ghost.y = 9;
            ghost.frightened = false;
            updateUI();
          } else {
            // Enemy caught Pac-Man
            lives--;
            if (lives <= 0) {
              gameLost = true;
            } else {
              // Reset Pac-Man position
              pac.x = 1; pac.y = 11; pac.dx = 0; pac.dy = 0;
            }
            updateUI();
          }
        }
      });
    }
    
    // Game logic
    let moveTimer = 0;
    const MOVE_SPEED = 8; // frames between moves (slower = higher number)
    
    function update() {
      // Don't update if game is over
      if (gameWon || gameLost) return;
      
      moveTimer++;
      
      // Update power timer
      if (powerTimer > 0) {
        powerTimer--;
        if (powerTimer === 0) {
          // Power effect ended
          ghosts.forEach(g => g.frightened = false);
        }
        updateUI();
      }
      
      // Handle input
      if (keys['ArrowUp'] || keys['w']) { pac.dx = 0; pac.dy = -1; }
      if (keys['ArrowDown'] || keys['s']) { pac.dx = 0; pac.dy = 1; }
      if (keys['ArrowLeft'] || keys['a']) { pac.dx = -1; pac.dy = 0; }
      if (keys['ArrowRight'] || keys['d']) { pac.dx = 1; pac.dy = 0; }
      
      // Update Pac-Man rotation based on direction
      if (pac.dx === 1) pac.rotation = 0;        // Right
      if (pac.dx === -1) pac.rotation = Math.PI; // Left  
      if (pac.dy === -1) pac.rotation = -Math.PI/2; // Up
      if (pac.dy === 1) pac.rotation = Math.PI/2;   // Down
      
      // Move Pac-Man (only every MOVE_SPEED frames)
      if (moveTimer >= MOVE_SPEED) {
        moveTimer = 0;
        
        const newX = pac.x + pac.dx;
        const newY = pac.y + pac.dy;
        if (newX >= 0 && newX < COLS && newY >= 0 && newY < ROWS) {
          const cell = board[newY][newX];
          if (cell !== '#') {
            pac.x = newX;
            pac.y = newY;
            
            // Collect dots
            if (cell === '.' || cell === 'o') {
              score += cell === 'o' ? 50 : 10;
              dots--;
              // Mark as collected in dynamic board
              board[newY][newX] = ' ';
              
              // Power pellet effect
              if (cell === 'o') {
                powerTimer = POWER_DURATION;
                ghosts.forEach(g => g.frightened = true);
              }
              
              // Check win condition
              if (dots === 0) {
                gameWon = true;
              }
              
              updateUI();
            }
          }
        }
        
        // Check collisions
        checkCollisions();
        
        // Move ghosts (same timing as Pac-Man)
        ghosts.forEach(ghost => {
          if (ghost.type === 'ally') {
            // AI ally follows player with some intelligence
            const dx = pac.x - ghost.x;
            const dy = pac.y - ghost.y;
            const distance = Math.abs(dx) + Math.abs(dy);
            
            // Only move if not too close to player (give some space)
            if (distance > 2) {
              if (Math.abs(dx) > Math.abs(dy)) {
                ghost.dx = dx > 0 ? 1 : -1;
                ghost.dy = 0;
              } else {
                ghost.dx = 0;
                ghost.dy = dy > 0 ? 1 : -1;
              }
            } else {
              ghost.dx = 0; ghost.dy = 0; // Stop when close
            }
          } else {
            // Enemy AI - try to move toward player occasionally
            if (Math.random() < 0.1) { // 10% chance to target player
              const dx = pac.x - ghost.x;
              const dy = pac.y - ghost.y;
              if (Math.abs(dx) > Math.abs(dy)) {
                ghost.dx = dx > 0 ? 1 : -1;
                ghost.dy = 0;
              } else {
                ghost.dx = 0;
                ghost.dy = dy > 0 ? 1 : -1;
              }
            }
          }
          
          // Update ghost rotation based on direction
          if (ghost.dx === 1) ghost.rotation = 0;
          if (ghost.dx === -1) ghost.rotation = Math.PI;
          if (ghost.dy === -1) ghost.rotation = -Math.PI/2;
          if (ghost.dy === 1) ghost.rotation = Math.PI/2;
          
          // Try to move in current direction
          let newGX = ghost.x + ghost.dx;
          let newGY = ghost.y + ghost.dy;
          
          // Check bounds and walls
          if (newGX >= 0 && newGX < COLS && newGY >= 0 && newGY < ROWS) {
            const cell = board[newGY][newGX];
            if (cell !== '#') {
              ghost.x = newGX;
              ghost.y = newGY;
            } else {
              // Hit wall - pick new random direction
              const directions = [[0,-1],[0,1],[-1,0],[1,0]];
              const validDirs = directions.filter(([dx,dy]) => {
                const testX = ghost.x + dx;
                const testY = ghost.y + dy;
                return testX >= 0 && testX < COLS && testY >= 0 && testY < ROWS && 
                       board[testY][testX] !== '#';
              });
              if (validDirs.length > 0) {
                const [newDx, newDy] = validDirs[Math.floor(Math.random() * validDirs.length)];
                ghost.dx = newDx;
                ghost.dy = newDy;
              }
            }
          } else {
            // Hit boundary - reverse direction
            ghost.dx = -ghost.dx;
            ghost.dy = -ghost.dy;
          }
        });
      }
    }
    
    // Rendering
    function render() {
      const theme = themes[themeIndex];
      
      // Clear canvas
      ctx.fillStyle = theme.road;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw maze
      for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
          const cell = board[y][x];
          const px = x * TILE;
          const py = y * TILE;
          
          if (cell === '#') {
            ctx.fillStyle = theme.wall;
            ctx.fillRect(px, py, TILE, TILE);
          } else if (cell === '.') {
            ctx.fillStyle = '#ffff00';
            ctx.beginPath();
            ctx.arc(px + TILE/2, py + TILE/2, 3, 0, Math.PI * 2);
            ctx.fill();
          } else if (cell === 'o') {
            ctx.fillStyle = '#ffaa00';
            ctx.beginPath();
            ctx.arc(px + TILE/2, py + TILE/2, 8, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      }
      
      // Draw Pac-Man
      drawPacMan(pac.x * TILE + TILE/2, pac.y * TILE + TILE/2, theme);
      
      // Draw ghosts
      ghosts.forEach((ghost, i) => {
        drawGhost(ghost.x * TILE + TILE/2, ghost.y * TILE + TILE/2, ghost, theme);
      });
    }
    
    // Pixar-themed character drawing functions
    function drawPacMan(x, y, theme) {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(pac.rotation);
      
      if (theme.name === 'Cars') {
        // Lightning McQueen - more realistic proportions
        const w = TILE * 1.2, h = TILE * 0.7;
        
        // Main car body with curves
        ctx.fillStyle = '#ff0000';
        ctx.beginPath();
        ctx.roundRect(-w/2, -h/2, w, h, h*0.2);
        ctx.fill();
        
        // Hood and roof details
        ctx.fillStyle = '#cc0000';
        ctx.beginPath();
        ctx.roundRect(-w*0.3, -h*0.4, w*0.6, h*0.3, h*0.1);
        ctx.fill();
        
        // Windshield with reflection
        ctx.fillStyle = '#87ceeb';
        ctx.beginPath();
        ctx.roundRect(-w*0.25, -h*0.35, w*0.5, h*0.25, h*0.05);
        ctx.fill();
        
        // Windshield highlight
        ctx.fillStyle = '#b8e0ff';
        ctx.beginPath();
        ctx.roundRect(-w*0.2, -h*0.3, w*0.15, h*0.1, h*0.02);
        ctx.fill();
        
        // Racing stripes and numbers
        ctx.fillStyle = '#ffff00';
        ctx.beginPath();
        ctx.roundRect(-w*0.08, -h/2, w*0.04, h, h*0.02);
        ctx.fill();
        ctx.beginPath();
        ctx.roundRect(w*0.04, -h/2, w*0.04, h, h*0.02);
        ctx.fill();
        
        // "95" number
        ctx.fillStyle = '#ffff00';
        ctx.font = `bold ${TILE*0.25}px Arial`;
        ctx.textAlign = 'center';
        ctx.fillText('95', 0, h*0.05);
        
        // Wheels with rims
        ctx.fillStyle = '#666';
        ctx.beginPath();
        ctx.arc(-w*0.3, h*0.55, TILE*0.18, 0, Math.PI * 2);
        ctx.arc(w*0.3, h*0.55, TILE*0.18, 0, Math.PI * 2);
        ctx.fill();
        
        // Wheel rims
        ctx.fillStyle = '#666';
        ctx.beginPath();
        ctx.arc(-w*0.3, h*0.55, TILE*0.12, 0, Math.PI * 2);
        ctx.arc(w*0.3, h*0.55, TILE*0.12, 0, Math.PI * 2);
        ctx.fill();
        
        // Eyes
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(-w*0.12, -h*0.15, TILE*0.1, 0, Math.PI * 2);
        ctx.arc(w*0.12, -h*0.15, TILE*0.1, 0, Math.PI * 2);
        ctx.fill();
        
        // Eye pupils
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(-w*0.12, -h*0.15, TILE*0.05, 0, Math.PI * 2);
        ctx.arc(w*0.12, -h*0.15, TILE*0.05, 0, Math.PI * 2);
        ctx.fill();
        
        // Eye highlights
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(-w*0.1, -h*0.18, TILE*0.02, 0, Math.PI * 2);
        ctx.arc(w*0.14, -h*0.18, TILE*0.02, 0, Math.PI * 2);
        ctx.fill();
        
      } else {
        // Nemo (clownfish) - more realistic and detailed
        const w = TILE * 0.9, h = TILE * 0.6;
        
        // Fish body with gradient effect
        ctx.fillStyle = '#ff7700';
        ctx.beginPath();
        ctx.ellipse(0, 0, w/2, h/2, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Body shading
        ctx.fillStyle = '#e65500';
        ctx.beginPath();
        ctx.ellipse(0, h*0.1, w*0.4, h*0.3, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // White stripes
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.ellipse(-w*0.15, 0, w*0.08, h*0.45, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(w*0.15, 0, w*0.08, h*0.45, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Black stripe outlines
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.ellipse(-w*0.15, 0, w*0.08, h*0.45, 0, 0, Math.PI * 2);
        ctx.stroke();
        ctx.beginPath();
        ctx.ellipse(w*0.15, 0, w*0.08, h*0.45, 0, 0, Math.PI * 2);
        ctx.stroke();
        
        // Tail fin with more detail
        ctx.fillStyle = '#ff7700';
        ctx.beginPath();
        ctx.moveTo(-w/2, 0);
        ctx.lineTo(-w/2 - TILE*0.4, -h*0.5);
        ctx.lineTo(-w/2 - TILE*0.35, 0);
        ctx.lineTo(-w/2 - TILE*0.4, h*0.5);
        ctx.closePath();
        ctx.fill();
        
        // Tail fin stripes
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-w/2 - TILE*0.38, -h*0.2);
        ctx.lineTo(-w/2 - TILE*0.38, h*0.2);
        ctx.stroke();
        
        // Dorsal and ventral fins
        ctx.fillStyle = '#ff7700';
        ctx.beginPath();
        ctx.moveTo(w*0.1, -h/2);
        ctx.lineTo(w*0.2, -h*0.7);
        ctx.lineTo(w*0.3, -h/2);
        ctx.closePath();
        ctx.fill();
        
        // Eye (bigger and more detailed)
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(w*0.25, -h*0.1, TILE*0.12, 0, Math.PI * 2);
        ctx.fill();
        
        // Eye pupil
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(w*0.25, -h*0.1, TILE*0.06, 0, Math.PI * 2);
        ctx.fill();
        
        // Eye highlight
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(w*0.27, -h*0.13, TILE*0.02, 0, Math.PI * 2);
        ctx.fill();
      }
      
      ctx.restore();
    }
    
    function drawGhost(x, y, ghost, theme) {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(ghost.rotation);
      
      if (theme.name === 'Cars') {
        if (ghost.type === 'ally') {
          // Mater - rusty tow truck
          drawMater(ghost);
        } else {
          // Rival cars with unique designs
          drawRivalCar(ghost);
        }
      } else {
        if (ghost.type === 'ally') {
          // Dory - blue tang fish
          drawDory(ghost);
        } else {
          // Various sea creatures
          drawSeaCreature(ghost);
        }
      }
      
      ctx.restore();
    }
    
    function drawMater(ghost) {
      const w = TILE * 1.1, h = TILE * 0.8;
      
      // Mater's rusty body
      ctx.fillStyle = ghost.frightened ? '#4444ff' : '#8B4513';
      ctx.beginPath();
      ctx.roundRect(-w/2, -h/2, w, h, h*0.15);
      ctx.fill();
      
      // Rust spots
      ctx.fillStyle = '#A0522D';
      ctx.beginPath();
      ctx.arc(-w*0.2, -h*0.1, TILE*0.05, 0, Math.PI * 2);
      ctx.arc(w*0.3, h*0.1, TILE*0.04, 0, Math.PI * 2);
      ctx.fill();
      
      // Tow hook
      ctx.strokeStyle = '#666';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(-w/2, 0);
      ctx.lineTo(-w/2 - TILE*0.2, 0);
      ctx.stroke();
      
      // Eyes (buck teeth style)
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(-w*0.1, -h*0.2, TILE*0.08, 0, Math.PI * 2);
      ctx.arc(w*0.1, -h*0.2, TILE*0.08, 0, Math.PI * 2);
      ctx.fill();
    }
    
    function drawRivalCar(ghost) {
      const w = TILE * 0.9, h = TILE * 0.6;
      const colors = ghost.frightened ? '#4444ff' : 
                    ['#2e7d32', '#0051ff', '#ffdd00', '#800080', '#ff4500'][ghost.color];
      const names = ['Chick', 'King', 'Storm', 'Cruz', 'Boost'][ghost.color];
      const numbers = ['86', '43', '20', '51', '33'][ghost.color];
      
      // Car body with aerodynamic shape
      ctx.fillStyle = colors;
      ctx.beginPath();
      ctx.roundRect(-w/2, -h/2, w, h, h*0.2);
      ctx.fill();
      
      // Racing details
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.roundRect(-w*0.2, -h*0.3, w*0.4, h*0.2, h*0.05);
      ctx.fill();
      
      // Racing number
      ctx.fillStyle = '#000';
      ctx.font = `bold ${TILE*0.2}px Arial`;
      ctx.textAlign = 'center';
      ctx.fillText(numbers, 0, h*0.05);
    }
    
    function drawDory(ghost) {
      const w = TILE * 0.8, h = TILE * 0.5;
      
      // Dory's blue body
      ctx.fillStyle = ghost.frightened ? '#4444ff' : '#4169E1';
      ctx.beginPath();
      ctx.ellipse(0, 0, w/2, h/2, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Yellow details
      ctx.fillStyle = '#FFD700';
      ctx.beginPath();
      ctx.ellipse(0, h*0.2, w*0.3, h*0.2, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Big forgetful eyes
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(-w*0.1, -h*0.1, TILE*0.08, 0, Math.PI * 2);
      ctx.arc(w*0.1, -h*0.1, TILE*0.08, 0, Math.PI * 2);
      ctx.fill();
    }
    
    function drawSeaCreature(ghost) {
      const r = TILE * 0.4;
      const colors = ghost.frightened ? '#4444ff' : 
                    ['#ff88ff', '#88ffff', '#ffaaff', '#aaaaff', '#ff6347'][ghost.color];
      const creatures = ['Jellyfish', 'Seahorse', 'Starfish', 'Octopus', 'Crab'][ghost.color];
      
      if (ghost.color === 0) {
        // Jellyfish with animated tentacles
        ctx.fillStyle = colors;
        ctx.beginPath();
        ctx.arc(0, -r*0.3, r, 0, Math.PI);
        ctx.closePath();
        ctx.fill();
        
        // Animated tentacles
        ctx.strokeStyle = colors;
        ctx.lineWidth = 4;
        for (let i = -2; i <= 2; i++) {
          ctx.beginPath();
          ctx.moveTo(i * r * 0.3, 0);
          const waveY = r * 0.9 + Math.sin(Date.now() / 150 + i) * r * 0.3;
          ctx.lineTo(i * r * 0.3, waveY);
          ctx.stroke();
        }
      } else {
        // Other sea creatures as simple colored shapes
        ctx.fillStyle = colors;
        ctx.beginPath();
        ctx.arc(0, 0, r*0.8, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Eyes for all sea creatures
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.arc(-r*0.2, -r*0.3, r*0.1, 0, Math.PI * 2);
      ctx.arc(r*0.2, -r*0.3, r*0.1, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // Game loop
    function gameLoop() {
      update();
      render();
      requestAnimationFrame(gameLoop);
    }
    
    // Start game
    initGame();
    updateUI();
    gameLoop();
    
    console.log('Safari Pac-Man loaded successfully!');
  </script>
</body>
</html> 