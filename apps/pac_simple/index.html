<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Safari Pac-Man</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body { margin:0; padding:20px; background:#000; font-family:monospace; color:#fff; display:flex; flex-direction:column; align-items:center; }
    canvas { border:2px solid #fff; background:#001122; }
    .ui { margin:10px 0; font-size:16px; }
    .controls { margin:10px 0; font-size:12px; }
  </style>
</head>
<body>
  <div class="ui" id="ui">SCORE: 0 | LIVES: 3 | THEME: Cars (press T)</div>
  <canvas id="game" width="784" height="644"></canvas>
  <div class="controls">Arrow keys to move | T to change theme | R to restart</div>

  <script>
    // Pure vanilla Canvas game - Safari Sequoia guaranteed
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const ui = document.getElementById('ui');
    
    // Game constants
    const TILE = 28; // Bigger tiles for easier visibility
    const COLS = 28;
    const ROWS = 23;
    
    // Simple maze (smaller for testing)
    const MAZE = [
      "############################",
      "#............##............#",
      "#.####.#####.##.#####.####.#",
      "#o####.#####.##.#####.####o#",
      "#..........................#",
      "#.####.##.########.##.####.#",
      "#......##....##....##......#",
      "######.##### ## #####.######",
      "     #.##### ## #####.#     ",
      "     #.##    GG    ##.#     ",
      "######.## ######## ##.######",
      "#P.........................#",
      "######.## ######## ##.######",
      "     #.##          ##.#     ",
      "######.## ######## ##.######",
      "#............##............#",
      "#.####.#####.##.#####.####.#",
      "#o..##................##..o#",
      "###.##.##.########.##.##.###",
      "#......##....##....##......#",
      "#.##########.##.##########.#",
      "#..........................#",
      "############################"
    ];
    
    // Game state
    let score = 0, lives = 3, dots = 0;
    let powerTimer = 0; // frames remaining for power pellet effect
    let gameWon = false, gameLost = false;
    const POWER_DURATION = 300; // frames (5 seconds at 60fps)
    let themeIndex = 0;
    const themes = [
      { name: 'Cars', pacColor: '#ff0000', ghostColors: ['#00ff00', '#0000ff', '#ffff00', '#ff00ff'], road: '#333', wall: '#666' },
      { name: 'Ocean', pacColor: '#ff7700', ghostColors: ['#ff88ff', '#88ffff', '#ffaaff', '#aaaaff'], road: '#002244', wall: '#004466' }
    ];
    
    // Dynamic board state (separate from static MAZE)
    let board = [];
    
    // Entities
    const pac = { x: 1, y: 11, dx: 0, dy: 0, size: 12 }; // Bigger for new tile size
    const ghosts = [
      { x: 13, y: 9, dx: 1, dy: 0, color: 0, size: 10, frightened: false },
      { x: 14, y: 9, dx: -1, dy: 0, color: 1, size: 10, frightened: false }
    ];
    
    // Find starting positions and count dots
    function initGame() {
      // Create dynamic board from static MAZE
      board = MAZE.map(row => row.split(''));
      console.log('MAZE length:', MAZE.length, 'ROWS:', ROWS);
      console.log('Board created, length:', board.length);
      dots = 0;
      for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
          if (!board[y]) {
            console.error('Missing board row at y:', y);
            return;
          }
          const cell = board[y][x];
          if (cell === 'P') { pac.x = x; pac.y = y; }
          if (cell === '.' || cell === 'o') dots++;
        }
      }
      console.log('Game initialized. Pac at:', pac.x, pac.y, 'Dots:', dots);
    }
    
    // Input handling
    const keys = {};
    window.addEventListener('keydown', e => {
      keys[e.key] = true;
      if (e.key === 't' || e.key === 'T') switchTheme();
      if (e.key === 'r' || e.key === 'R') restart();
    });
    window.addEventListener('keyup', e => keys[e.key] = false);
    
    function switchTheme() {
      themeIndex = (themeIndex + 1) % themes.length;
      updateUI();
    }
    
    function restart() {
      score = 0; lives = 3; powerTimer = 0; gameWon = false; gameLost = false;
      pac.x = 1; pac.y = 11; pac.dx = 0; pac.dy = 0;
      ghosts.forEach((g, i) => {
        g.x = 13 + i; g.y = 9; g.dx = i === 0 ? 1 : -1; g.dy = 0; g.frightened = false;
      });
      initGame();
      updateUI();
    }
    
    function updateUI() {
      let status = '';
      if (gameWon) status = ' | YOU WIN!';
      else if (gameLost) status = ' | GAME OVER';
      else if (powerTimer > 0) status = ` | POWER: ${Math.ceil(powerTimer/60)}s`;
      
      ui.textContent = `SCORE: ${score} | LIVES: ${lives} | THEME: ${themes[themeIndex].name} (press T)${status}`;
    }
    
    // Helper functions
    function distance(a, b) {
      return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
    }
    
    function checkCollisions() {
      // Pac-Man vs Ghosts
      ghosts.forEach((ghost, i) => {
        if (distance(pac, ghost) < 0.8) {
          if (ghost.frightened) {
            // Eat frightened ghost
            score += 200;
            ghost.x = 13 + i; // Reset to start position
            ghost.y = 9;
            ghost.frightened = false;
            updateUI();
          } else {
            // Ghost caught Pac-Man
            lives--;
            if (lives <= 0) {
              gameLost = true;
            } else {
              // Reset Pac-Man position
              pac.x = 1; pac.y = 11; pac.dx = 0; pac.dy = 0;
            }
            updateUI();
          }
        }
      });
    }
    
    // Game logic
    let moveTimer = 0;
    const MOVE_SPEED = 8; // frames between moves (slower = higher number)
    
    function update() {
      // Don't update if game is over
      if (gameWon || gameLost) return;
      
      moveTimer++;
      
      // Update power timer
      if (powerTimer > 0) {
        powerTimer--;
        if (powerTimer === 0) {
          // Power effect ended
          ghosts.forEach(g => g.frightened = false);
        }
        updateUI();
      }
      
      // Handle input
      if (keys['ArrowUp'] || keys['w']) { pac.dx = 0; pac.dy = -1; }
      if (keys['ArrowDown'] || keys['s']) { pac.dx = 0; pac.dy = 1; }
      if (keys['ArrowLeft'] || keys['a']) { pac.dx = -1; pac.dy = 0; }
      if (keys['ArrowRight'] || keys['d']) { pac.dx = 1; pac.dy = 0; }
      
      // Move Pac-Man (only every MOVE_SPEED frames)
      if (moveTimer >= MOVE_SPEED) {
        moveTimer = 0;
        
        const newX = pac.x + pac.dx;
        const newY = pac.y + pac.dy;
        if (newX >= 0 && newX < COLS && newY >= 0 && newY < ROWS) {
          const cell = board[newY][newX];
          if (cell !== '#') {
            pac.x = newX;
            pac.y = newY;
            
            // Collect dots
            if (cell === '.' || cell === 'o') {
              score += cell === 'o' ? 50 : 10;
              dots--;
              // Mark as collected in dynamic board
              board[newY][newX] = ' ';
              
              // Power pellet effect
              if (cell === 'o') {
                powerTimer = POWER_DURATION;
                ghosts.forEach(g => g.frightened = true);
              }
              
              // Check win condition
              if (dots === 0) {
                gameWon = true;
              }
              
              updateUI();
            }
          }
        }
        
        // Check collisions
        checkCollisions();
        
        // Move ghosts (same timing as Pac-Man)
        ghosts.forEach(ghost => {
          // Try to move in current direction
          let newGX = ghost.x + ghost.dx;
          let newGY = ghost.y + ghost.dy;
          
          // Check bounds and walls
          if (newGX >= 0 && newGX < COLS && newGY >= 0 && newGY < ROWS) {
            const cell = board[newGY][newGX];
            if (cell !== '#') {
              ghost.x = newGX;
              ghost.y = newGY;
            } else {
              // Hit wall - pick new random direction
              const directions = [[0,-1],[0,1],[-1,0],[1,0]];
              const validDirs = directions.filter(([dx,dy]) => {
                const testX = ghost.x + dx;
                const testY = ghost.y + dy;
                return testX >= 0 && testX < COLS && testY >= 0 && testY < ROWS && 
                       board[testY][testX] !== '#';
              });
              if (validDirs.length > 0) {
                const [newDx, newDy] = validDirs[Math.floor(Math.random() * validDirs.length)];
                ghost.dx = newDx;
                ghost.dy = newDy;
              }
            }
          } else {
            // Hit boundary - reverse direction
            ghost.dx = -ghost.dx;
            ghost.dy = -ghost.dy;
          }
        });
      }
    }
    
    // Rendering
    function render() {
      const theme = themes[themeIndex];
      
      // Clear canvas
      ctx.fillStyle = theme.road;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw maze
      for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
          const cell = board[y][x];
          const px = x * TILE;
          const py = y * TILE;
          
          if (cell === '#') {
            ctx.fillStyle = theme.wall;
            ctx.fillRect(px, py, TILE, TILE);
          } else if (cell === '.') {
            ctx.fillStyle = '#ffff00';
            ctx.beginPath();
            ctx.arc(px + TILE/2, py + TILE/2, 3, 0, Math.PI * 2);
            ctx.fill();
          } else if (cell === 'o') {
            ctx.fillStyle = '#ffaa00';
            ctx.beginPath();
            ctx.arc(px + TILE/2, py + TILE/2, 8, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      }
      
      // Draw Pac-Man
      drawPacMan(pac.x * TILE + TILE/2, pac.y * TILE + TILE/2, theme);
      
      // Draw ghosts
      ghosts.forEach((ghost, i) => {
        drawGhost(ghost.x * TILE + TILE/2, ghost.y * TILE + TILE/2, ghost, theme);
      });
    }
    
    // Pixar-themed character drawing functions
    function drawPacMan(x, y, theme) {
      ctx.save();
      ctx.translate(x, y);
      
      if (theme.name === 'Cars') {
        // Lightning McQueen
        const w = TILE * 0.8, h = TILE * 0.5;
        
        // Car body (red)
        ctx.fillStyle = '#ff0000';
        ctx.fillRect(-w/2, -h/2, w, h);
        
        // Windshield
        ctx.fillStyle = '#87ceeb';
        ctx.fillRect(-w*0.3, -h*0.3, w*0.6, h*0.3);
        
        // Racing stripes
        ctx.fillStyle = '#ffff00';
        ctx.fillRect(-w*0.1, -h/2, w*0.05, h);
        ctx.fillRect(w*0.05, -h/2, w*0.05, h);
        
        // Wheels
        ctx.fillStyle = '#333';
        ctx.beginPath();
        ctx.arc(-w*0.25, h*0.6, TILE*0.15, 0, Math.PI * 2);
        ctx.arc(w*0.25, h*0.6, TILE*0.15, 0, Math.PI * 2);
        ctx.fill();
        
        // Eyes
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(-w*0.15, -h*0.1, TILE*0.08, 0, Math.PI * 2);
        ctx.arc(w*0.15, -h*0.1, TILE*0.08, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(-w*0.15, -h*0.1, TILE*0.04, 0, Math.PI * 2);
        ctx.arc(w*0.15, -h*0.1, TILE*0.04, 0, Math.PI * 2);
        ctx.fill();
        
      } else {
        // Nemo (clownfish)
        const w = TILE * 0.7, h = TILE * 0.4;
        
        // Fish body (orange)
        ctx.fillStyle = '#ff7700';
        ctx.beginPath();
        ctx.ellipse(0, 0, w/2, h/2, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // White stripes
        ctx.fillStyle = '#fff';
        ctx.fillRect(-w*0.2, -h/2, w*0.1, h);
        ctx.fillRect(w*0.1, -h/2, w*0.1, h);
        
        // Black stripe outlines
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.rect(-w*0.2, -h/2, w*0.1, h);
        ctx.rect(w*0.1, -h/2, w*0.1, h);
        ctx.stroke();
        
        // Tail fin
        ctx.fillStyle = '#ff7700';
        ctx.beginPath();
        ctx.moveTo(-w/2, 0);
        ctx.lineTo(-w/2 - TILE*0.3, -h*0.4);
        ctx.lineTo(-w/2 - TILE*0.3, h*0.4);
        ctx.closePath();
        ctx.fill();
        
        // Eye
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(w*0.2, -h*0.1, TILE*0.1, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(w*0.2, -h*0.1, TILE*0.05, 0, Math.PI * 2);
        ctx.fill();
      }
      
      ctx.restore();
    }
    
    function drawGhost(x, y, ghost, theme) {
      ctx.save();
      ctx.translate(x, y);
      
      if (theme.name === 'Cars') {
        // Rival cars (Chick Hicks, King, etc.)
        const w = TILE * 0.7, h = TILE * 0.45;
        const colors = ghost.frightened ? '#4444ff' : 
                      ['#2e7d32', '#0051ff', '#ffdd00', '#ff00ff'][ghost.color];
        
        // Car body
        ctx.fillStyle = colors;
        ctx.fillRect(-w/2, -h/2, w, h);
        
        // Windshield
        ctx.fillStyle = '#87ceeb';
        ctx.fillRect(-w*0.25, -h*0.3, w*0.5, h*0.25);
        
        // Wheels
        ctx.fillStyle = '#333';
        ctx.beginPath();
        ctx.arc(-w*0.2, h*0.6, TILE*0.12, 0, Math.PI * 2);
        ctx.arc(w*0.2, h*0.6, TILE*0.12, 0, Math.PI * 2);
        ctx.fill();
        
        // Racing number
        ctx.fillStyle = '#fff';
        ctx.font = `${TILE*0.3}px Arial`;
        ctx.textAlign = 'center';
        const numbers = ['86', '43', '34', '51'];
        ctx.fillText(numbers[ghost.color] || '99', 0, h*0.1);
        
      } else {
        // Sea creatures (jellyfish, etc.)
        const r = TILE * 0.35;
        const colors = ghost.frightened ? '#4444ff' : 
                      ['#ff88ff', '#88ffff', '#ffaaff', '#aaaaff'][ghost.color];
        
        // Jellyfish bell
        ctx.fillStyle = colors;
        ctx.beginPath();
        ctx.arc(0, -r*0.3, r, 0, Math.PI);
        ctx.closePath();
        ctx.fill();
        
        // Jellyfish tentacles
        ctx.strokeStyle = colors;
        ctx.lineWidth = 3;
        for (let i = -2; i <= 2; i++) {
          ctx.beginPath();
          ctx.moveTo(i * r * 0.3, 0);
          const waveY = r * 0.8 + Math.sin(Date.now() / 200 + i) * r * 0.2;
          ctx.lineTo(i * r * 0.3, waveY);
          ctx.stroke();
        }
        
        // Eyes
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(-r*0.3, -r*0.5, r*0.15, 0, Math.PI * 2);
        ctx.arc(r*0.3, -r*0.5, r*0.15, 0, Math.PI * 2);
        ctx.fill();
      }
      
      ctx.restore();
    }
    
    // Game loop
    function gameLoop() {
      update();
      render();
      requestAnimationFrame(gameLoop);
    }
    
    // Start game
    initGame();
    updateUI();
    gameLoop();
    
    console.log('Safari Pac-Man loaded successfully!');
  </script>
</body>
</html> 